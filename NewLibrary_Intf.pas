unit NewLibrary_Intf;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ Do not modify this unit manually, or your changes will be lost when this   }
{ unit is regenerated the next time you compile the project.                 }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, TypInfo,
  {RemObjects:} uROXMLIntf, uROClasses, uROClient, uROTypes, uROClientIntf;

const
  { Library ID }
  LibraryUID = '{0B77A867-DB3E-473B-87F1-69AFEC6DA86D}';
  WSDLLocation = 'http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx?wsdl';
  TargetNamespace = 'http://webxml.com.cn/';

  { Service Interface ID's }
  IStockInfoWSSoap_IID : TGUID = '{B5198F97-1931-43D3-BC34-C4DA653DFEB1}';
  IStockInfoWSSoap12_IID : TGUID = '{F75EAA05-86B7-4C8C-B038-4D6D449DADBC}';
  StockInfoWSSoap_EndPointURI = 'http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx';
  StockInfoWSSoap12_EndPointURI = 'http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx';

type
  TSeekOrigin = Classes.TSeekOrigin; // fake declaration
  { Forward declarations }
  IStockInfoWSSoap = interface;
  IStockInfoWSSoap12 = interface;

  ArrayOfString = class;

  getStockInfo = class;
  getStockInfoResponse = class;

  { getStockInfo }
  getStockInfo = class(TROComplexType)
  private
    ftheStockCode: UnicodeString;
    fuserID: UnicodeString;
  public
    class function GetAttributeCount: Integer; override;
    class function GetAttributeName(aIndex: Integer): string; override;
    class function GetAttributeValue(aIndex: Integer): string; override;

    procedure Assign(iSource: TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
  published
    property theStockCode:UnicodeString read ftheStockCode write ftheStockCode;
    property userID:UnicodeString read fuserID write fuserID;
  end;

  { getStockInfoCollection }
  getStockInfoCollection = class(TROCollection)
  protected
    constructor Create(aItemClass: TCollectionItemClass); overload;
    function GetItems(aIndex: Integer): getStockInfo;
    procedure SetItems(aIndex: Integer; const Value: getStockInfo);
  public
    constructor Create; overload;
    function Add: getStockInfo; reintroduce;
    property Items[Index: Integer]:getStockInfo read GetItems write SetItems; default;
  end;

  { getStockInfoResponse }
  getStockInfoResponse = class(TROComplexType)
  private
    fgetStockInfoResult: ArrayOfString;
    function GetgetStockInfoResult: ArrayOfString;
  protected
    property int_getStockInfoResult: ArrayOfString read fgetStockInfoResult;
  public
    class function GetAttributeCount: Integer; override;
    class function GetAttributeName(aIndex: Integer): string; override;
    class function GetAttributeValue(aIndex: Integer): string; override;

    procedure Assign(iSource: TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
  published
    property getStockInfoResult:ArrayOfString read GetgetStockInfoResult write fgetStockInfoResult;
  end;

  { getStockInfoResponseCollection }
  getStockInfoResponseCollection = class(TROCollection)
  protected
    constructor Create(aItemClass: TCollectionItemClass); overload;
    function GetItems(aIndex: Integer): getStockInfoResponse;
    procedure SetItems(aIndex: Integer; const Value: getStockInfoResponse);
  public
    constructor Create; overload;
    function Add: getStockInfoResponse; reintroduce;
    property Items[Index: Integer]:getStockInfoResponse read GetItems write SetItems; default;
  end;

  { ArrayOfString }
  ArrayOfString_UnicodeString = array of UnicodeString;
  ArrayOfString = class(TROArray)
  private
    fCount: Integer;
    fItems : ArrayOfString_UnicodeString;
  protected
    procedure Grow; virtual;
    function GetItems(aIndex: Integer): UnicodeString;
    procedure SetItems(aIndex: Integer; const Value: UnicodeString);
    function GetCount: Integer; override;
  public
    class function GetAttributeCount: Integer; override;
    class function GetAttributeName(aIndex: Integer): string; override;
    class function GetAttributeValue(aIndex: Integer): string; override;
    class function GetItemType: PTypeInfo; override;
    class function GetItemSize: Integer; override;

    function GetItemRef(aIndex: Integer): pointer; override;
    procedure Clear; override;
    procedure Delete(aIndex: Integer); override;
    procedure Resize(ElementCount: Integer); override;

    procedure Assign(iSource:TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
    function Add(const Value:UnicodeString): Integer;
    function GetIndex(const aValue: UnicodeString; const aStartFrom: Integer = 0) : Integer; overload;
    function GetIndex(const aPropertyName : string;
                      const aPropertyValue : Variant;
                      StartFrom : Integer = 0;
                      Options : TROSearchOptions = [soIgnoreCase]) : Integer; override;
    function IndexOf(const aValue: UnicodeString; const aStartFrom: Integer = 0): Integer;

    property Count : Integer read GetCount;
    property Items[Index: Integer]:UnicodeString read GetItems write SetItems; default;
    property InnerArray: ArrayOfString_UnicodeString read fItems;
  end;

  { IStockInfoWSSoap }
  IStockInfoWSSoap = interface
    ['{B5198F97-1931-43D3-BC34-C4DA653DFEB1}']
    function getStockInfo(const getStockInfo: getStockInfo): getStockInfoResponse;
  end;

  { CoStockInfoWSSoap }
  CoStockInfoWSSoap = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IStockInfoWSSoap; overload;
    class function Create(const aUri: TROUri): IStockInfoWSSoap; overload;
    class function Create(const aUrl: string): IStockInfoWSSoap; overload;
  end;

  { TStockInfoWSSoap_Proxy }
  TStockInfoWSSoap_Proxy = class(TROProxy, IStockInfoWSSoap)
  protected
    function __GetInterfaceName:string; override;

    function getStockInfo(const getStockInfo: getStockInfo): getStockInfoResponse;
  end;

  { IStockInfoWSSoap12 }
  IStockInfoWSSoap12 = interface
    ['{F75EAA05-86B7-4C8C-B038-4D6D449DADBC}']
    function getStockInfo(const getStockInfo: getStockInfo): getStockInfoResponse;
  end;

  { CoStockInfoWSSoap12 }
  CoStockInfoWSSoap12 = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IStockInfoWSSoap12; overload;
    class function Create(const aUri: TROUri): IStockInfoWSSoap12; overload;
    class function Create(const aUrl: string): IStockInfoWSSoap12; overload;
  end;

  { TStockInfoWSSoap12_Proxy }
  TStockInfoWSSoap12_Proxy = class(TROProxy, IStockInfoWSSoap12)
  protected
    function __GetInterfaceName:string; override;

    function getStockInfo(const getStockInfo: getStockInfo): getStockInfoResponse;
  end;

implementation

uses
  {vcl:} SysUtils,
  {RemObjects:} uROEventRepository, uROSerializer, uRORes;

{ ArrayOfString }

class function ArrayOfString.GetAttributeCount: Integer;
begin
  Result := 4;
end;

class function ArrayOfString.GetAttributeName(aIndex: Integer): string;
begin
  case aIndex of
    0: Result := 'minOccurs';
    1: Result := 'maxOccurs';
    2: Result := 'ImportedFromNamespace';
    3: Result := 'ElementName';
  end;
end;

class function ArrayOfString.GetAttributeValue(aIndex: Integer): string;
begin
  case aIndex of
    0: Result := '0';
    1: Result := '-1';
    2: Result := 'http://webxml.com.cn/';
    3: Result := 'string';
  end;
end;

procedure ArrayOfString.Assign(iSource: TPersistent);
var
  lSource: ArrayOfString;
  i: Integer;
begin
  if (iSource is ArrayOfString) then begin
    lSource := ArrayOfString(iSource);
    Self.Clear();

    Self.Resize(lSource.Count);
    for i := 0 to lSource.Count-1 do
      Self.Items[i] := lSource.Items[i];
  end
  else begin
    inherited Assign(iSource);
  end;
end;

class function ArrayOfString.GetItemType: PTypeInfo;
begin
  Result := System.TypeInfo(UnicodeString);
end;

class function ArrayOfString.GetItemSize: Integer;
begin
  Result := System.SizeOf(UnicodeString);
end;

function ArrayOfString.GetItems(aIndex: Integer): UnicodeString;
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  Result := fItems[aIndex];
end;

function ArrayOfString.GetItemRef(aIndex: Integer): pointer;
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  Result := @fItems[aIndex];
end;

procedure ArrayOfString.Clear;
begin
  System.SetLength(fItems, 0);
  FCount := 0;
end;

procedure ArrayOfString.Delete(aIndex: Integer);
var
  i: Integer;
begin
  if (aIndex >= Self.Count) then uROClasses.RaiseError(err_InvalidIndex, [aIndex]);

  if (aIndex < Self.Count-1) then
    for i := aIndex to Self.Count-2 do fItems[i] := fItems[i+1];

  System.SetLength(fItems, Self.Count-1);
  System.Dec(FCount);
end;

procedure ArrayOfString.SetItems(aIndex: Integer; const Value: UnicodeString);
begin
  if (aIndex < 0) or (aIndex >= Self.Count) then uROClasses.RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  fItems[aIndex] := Value;
end;

procedure ArrayOfString.Resize(ElementCount: Integer);
begin
  if fCount = ElementCount then Exit;
  System.SetLength(fItems, ElementCount);
  FCount := ElementCount;
end;

function ArrayOfString.GetCount: Integer;
begin
  Result := FCount;
end;

procedure ArrayOfString.Grow;
var
  lDelta, lCapacity: Integer;
begin
  lCapacity := System.Length(fItems);
  if lCapacity > 64 then
    lDelta := lCapacity div 4
  else
    if lCapacity > 8 then
      lDelta := 16
   else
      lDelta := 4;
  System.SetLength(fItems, lCapacity + lDelta);
end;

function ArrayOfString.Add(const Value: UnicodeString): Integer;
begin
  Result := Self.Count;
  if System.Length(fItems) = Result then
    Self.Grow;
  fItems[Result] := Value;
  System.Inc(fCount);
end;

function ArrayOfString.GetIndex(const aValue: UnicodeString; const aStartFrom: Integer = 0) : Integer;
begin
  Result := Self.IndexOf(aValue, aStartFrom);
end;

function ArrayOfString.GetIndex(const aPropertyName : string;
  const aPropertyValue : Variant; StartFrom : Integer;
  Options : TROSearchOptions) : Integer;
begin
  Result := -1;
end;

function ArrayOfString.IndexOf(const aValue: UnicodeString; const aStartFrom: Integer = 0): Integer;
begin
  for Result := aStartFrom to Self.Count-1 do
    if Items[Result] = aValue then Exit;
  Result := -1;
end;

procedure ArrayOfString.ReadComplex(ASerializer: TObject);
var
  lval: UnicodeString;
  i: Integer;
begin
  for i := 0 to Self.Count-1 do begin
{$IFDEF UNICODE}
      TROSerializer(ASerializer).ReadUnicodeString(TROSerializer(ASerializer).GetArrayElementName(GetItemType, GetItemRef(i)), lval, i);
{$ELSE}
      TROSerializer(ASerializer).ReadWideString(TROSerializer(ASerializer).GetArrayElementName(GetItemType, GetItemRef(i)), lval, i);
{$ENDIF}
    Self.Items[i] := lval;
  end;
end;

procedure ArrayOfString.WriteComplex(ASerializer: TObject);
var
  i: Integer;
begin
  TROSerializer(ASerializer).ChangeClass(ArrayOfString);
  for i := 0 to Self.Count-1 do
{$IFDEF UNICODE}
      TROSerializer(ASerializer).WriteUnicodeString(TROSerializer(ASerializer).GetArrayElementName(GetItemType, GetItemRef(i)), fItems[i], i);
{$ELSE}
      TROSerializer(ASerializer).WriteWideString(TROSerializer(ASerializer).GetArrayElementName(GetItemType, GetItemRef(i)), fItems[i], i);
{$ENDIF}
end;

{ getStockInfo }

class function getStockInfo.GetAttributeCount: Integer;
begin
  Result := 1;
end;

class function getStockInfo.GetAttributeName(aIndex: Integer): string;
begin
  case aIndex of
    0: Result := 'ImportedFromNamespace';
  end;
end;

class function getStockInfo.GetAttributeValue(aIndex: Integer): string;
begin
  case aIndex of
    0: Result := 'http://webxml.com.cn/';
  end;
end;

procedure getStockInfo.Assign(iSource: TPersistent); 
var
  lSource: NewLibrary_Intf.getStockInfo;
begin
  inherited Assign(iSource);
  if (iSource is NewLibrary_Intf.getStockInfo) then begin
    lSource := NewLibrary_Intf.getStockInfo(iSource);

    Self.theStockCode := lSource.theStockCode;
    Self.userID := lSource.userID;
  end;
end;

procedure getStockInfo.ReadComplex(ASerializer: TObject);
var
  l_theStockCode: UnicodeString;
  l_userID: UnicodeString;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    l_theStockCode := Self.theStockCode;
    try
{$IFDEF UNICODE}
      TROSerializer(ASerializer).ReadUnicodeString('theStockCode', l_theStockCode);
{$ELSE}
      TROSerializer(ASerializer).ReadWideString('theStockCode', l_theStockCode);
{$ENDIF}
    except
      on E: SysUtils.Exception do
        uROClasses.RaiseError(SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'theStockCode']));
    end;
    Self.theStockCode := l_theStockCode;
    l_userID := Self.userID;
    try
{$IFDEF UNICODE}
      TROSerializer(ASerializer).ReadUnicodeString('userID', l_userID);
{$ELSE}
      TROSerializer(ASerializer).ReadWideString('userID', l_userID);
{$ENDIF}
    except
      on E: SysUtils.Exception do
        uROClasses.RaiseError(SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'userID']));
    end;
    Self.userID := l_userID;
  end
  else begin
    l_theStockCode := Self.theStockCode;
    try
{$IFDEF UNICODE}
      TROSerializer(ASerializer).ReadUnicodeString('theStockCode', l_theStockCode);
{$ELSE}
      TROSerializer(ASerializer).ReadWideString('theStockCode', l_theStockCode);
{$ENDIF}
    except
      on E: SysUtils.Exception do
        uROClasses.RaiseError(SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'theStockCode']));
    end;
    Self.theStockCode := l_theStockCode;
    l_userID := Self.userID;
    try
{$IFDEF UNICODE}
      TROSerializer(ASerializer).ReadUnicodeString('userID', l_userID);
{$ELSE}
      TROSerializer(ASerializer).ReadWideString('userID', l_userID);
{$ENDIF}
    except
      on E: SysUtils.Exception do
        uROClasses.RaiseError(SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'userID']));
    end;
    Self.userID := l_userID;
  end;
end;

procedure getStockInfo.WriteComplex(ASerializer: TObject);
var
  l_theStockCode: UnicodeString;
  l_userID: UnicodeString;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    TROSerializer(ASerializer).ChangeClass(getStockInfo);
    l_theStockCode := Self.theStockCode;
{$IFDEF UNICODE}
    TROSerializer(ASerializer).WriteUnicodeString('theStockCode', l_theStockCode);
{$ELSE}
    TROSerializer(ASerializer).WriteWideString('theStockCode', l_theStockCode);
{$ENDIF}
    l_userID := Self.userID;
{$IFDEF UNICODE}
    TROSerializer(ASerializer).WriteUnicodeString('userID', l_userID);
{$ELSE}
    TROSerializer(ASerializer).WriteWideString('userID', l_userID);
{$ENDIF}
  end
  else begin
    l_theStockCode := Self.theStockCode;
{$IFDEF UNICODE}
    TROSerializer(ASerializer).WriteUnicodeString('theStockCode', l_theStockCode);
{$ELSE}
    TROSerializer(ASerializer).WriteWideString('theStockCode', l_theStockCode);
{$ENDIF}
    l_userID := Self.userID;
{$IFDEF UNICODE}
    TROSerializer(ASerializer).WriteUnicodeString('userID', l_userID);
{$ELSE}
    TROSerializer(ASerializer).WriteWideString('userID', l_userID);
{$ENDIF}
  end;
end;

{ getStockInfoCollection }
constructor getStockInfoCollection.Create;
begin
  inherited Create(getStockInfo);
end;

constructor getStockInfoCollection.Create(aItemClass: TCollectionItemClass);
begin
  inherited Create(aItemClass);
end;

function getStockInfoCollection.Add: getStockInfo;
begin
  Result := getStockInfo(inherited Add);
end;

function getStockInfoCollection.GetItems(aIndex: Integer): getStockInfo;
begin
  Result := getStockInfo(inherited Items[aIndex]);
end;

procedure getStockInfoCollection.SetItems(aIndex: Integer; const Value: getStockInfo);
begin
  getStockInfo(inherited Items[aIndex]).Assign(Value);
end;

{ getStockInfoResponse }

class function getStockInfoResponse.GetAttributeCount: Integer;
begin
  Result := 1;
end;

class function getStockInfoResponse.GetAttributeName(aIndex: Integer): string;
begin
  case aIndex of
    0: Result := 'ImportedFromNamespace';
  end;
end;

class function getStockInfoResponse.GetAttributeValue(aIndex: Integer): string;
begin
  case aIndex of
    0: Result := 'http://webxml.com.cn/';
  end;
end;

procedure getStockInfoResponse.Assign(iSource: TPersistent); 
var
  lSource: NewLibrary_Intf.getStockInfoResponse;
begin
  inherited Assign(iSource);
  if (iSource is NewLibrary_Intf.getStockInfoResponse) then begin
    lSource := NewLibrary_Intf.getStockInfoResponse(iSource);

    if System.Assigned(lSource.fgetStockInfoResult) then 
      Self.getStockInfoResult.Assign(lSource.fgetStockInfoResult)
    else
      SysUtils.FreeAndNil(fgetStockInfoResult);
  end;
end;

function getStockInfoResponse.GetgetStockInfoResult: ArrayOfString;
begin
  if (fgetStockInfoResult = nil) then fgetStockInfoResult := ArrayOfString.Create();
  Result := fgetStockInfoResult;
end;

procedure getStockInfoResponse.ReadComplex(ASerializer: TObject);
var
  l_getStockInfoResult: ArrayOfString;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    l_getStockInfoResult := int_getStockInfoResult;
    try
      TROSerializer(ASerializer).ReadArray('getStockInfoResult', ArrayOfString, l_getStockInfoResult);
    except
      on E: SysUtils.Exception do
        uROClasses.RaiseError(SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'getStockInfoResult']));
    end;
    if int_getStockInfoResult <> l_getStockInfoResult then Self.getStockInfoResult.Free;
    Self.getStockInfoResult := l_getStockInfoResult;
  end
  else begin
    l_getStockInfoResult := int_getStockInfoResult;
    try
      TROSerializer(ASerializer).ReadArray('getStockInfoResult', ArrayOfString, l_getStockInfoResult);
    except
      on E: SysUtils.Exception do
        uROClasses.RaiseError(SysUtils.Format('Exception "%s" with message "%s" happens during reading field "%s".', [E.ClassName, E.Message, 'getStockInfoResult']));
    end;
    if int_getStockInfoResult <> l_getStockInfoResult then getStockInfoResult.Free;
    Self.getStockInfoResult := l_getStockInfoResult;
  end;
end;

procedure getStockInfoResponse.WriteComplex(ASerializer: TObject);
var
  l_getStockInfoResult: ArrayOfString;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    TROSerializer(ASerializer).ChangeClass(getStockInfoResponse);
    l_getStockInfoResult := int_getStockInfoResult;
    TROSerializer(ASerializer).WriteArray('getStockInfoResult', l_getStockInfoResult, ArrayOfString);
  end
  else begin
    l_getStockInfoResult := int_getStockInfoResult;
    TROSerializer(ASerializer).WriteArray('getStockInfoResult', l_getStockInfoResult, ArrayOfString);
  end;
end;

{ getStockInfoResponseCollection }
constructor getStockInfoResponseCollection.Create;
begin
  inherited Create(getStockInfoResponse);
end;

constructor getStockInfoResponseCollection.Create(aItemClass: TCollectionItemClass);
begin
  inherited Create(aItemClass);
end;

function getStockInfoResponseCollection.Add: getStockInfoResponse;
begin
  Result := getStockInfoResponse(inherited Add);
end;

function getStockInfoResponseCollection.GetItems(aIndex: Integer): getStockInfoResponse;
begin
  Result := getStockInfoResponse(inherited Items[aIndex]);
end;

procedure getStockInfoResponseCollection.SetItems(aIndex: Integer; const Value: getStockInfoResponse);
begin
  getStockInfoResponse(inherited Items[aIndex]).Assign(Value);
end;

{ CoStockInfoWSSoap }

class function CoStockInfoWSSoap.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IStockInfoWSSoap;
begin
  Result := TStockInfoWSSoap_Proxy.Create(aMessage, aTransportChannel);
end;

class function CoStockInfoWSSoap.Create(const aUri: TROUri): IStockInfoWSSoap;
begin
  Result := TStockInfoWSSoap_Proxy.Create(aUri);
end;

class function CoStockInfoWSSoap.Create(const aUrl: string): IStockInfoWSSoap;
begin
  Result := TStockInfoWSSoap_Proxy.Create(aUrl);
end;

{ TStockInfoWSSoap_Proxy }

function TStockInfoWSSoap_Proxy.__GetInterfaceName:string;
begin
  Result := 'StockInfoWSSoap';
end;

function TStockInfoWSSoap_Proxy.getStockInfo(const getStockInfo: getStockInfo): getStockInfoResponse;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
    lMessage.SetAttributes(lTransportChannel, ['Action', 'Location', 'remap_getStockInfo', 'Style', 'TargetNamespace', 'Type', 'Use'
      , 'Wsdl'], 
      ['http://webxml.com.cn/getStockInfo', 'http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx', 'http://webxml.com.cn/getStockInfo', 'document', TargetNamespace, 'SOAP', 'literal'
      , WSDLLocation]);
  try
    Result := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'getStockInfo');
    lMessage.Write('getStockInfo', System.TypeInfo(NewLibrary_Intf.getStockInfo), getStockInfo, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('getStockInfoResponse', System.TypeInfo(NewLibrary_Intf.getStockInfoResponse), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

{ CoStockInfoWSSoap12 }

class function CoStockInfoWSSoap12.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IStockInfoWSSoap12;
begin
  Result := TStockInfoWSSoap12_Proxy.Create(aMessage, aTransportChannel);
end;

class function CoStockInfoWSSoap12.Create(const aUri: TROUri): IStockInfoWSSoap12;
begin
  Result := TStockInfoWSSoap12_Proxy.Create(aUri);
end;

class function CoStockInfoWSSoap12.Create(const aUrl: string): IStockInfoWSSoap12;
begin
  Result := TStockInfoWSSoap12_Proxy.Create(aUrl);
end;

{ TStockInfoWSSoap12_Proxy }

function TStockInfoWSSoap12_Proxy.__GetInterfaceName:string;
begin
  Result := 'StockInfoWSSoap12';
end;

function TStockInfoWSSoap12_Proxy.getStockInfo(const getStockInfo: getStockInfo): getStockInfoResponse;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
    lMessage.SetAttributes(lTransportChannel, ['Action', 'Location', 'remap_getStockInfo', 'Style', 'TargetNamespace', 'Type', 'Use'
      , 'Wsdl'], 
      ['http://webxml.com.cn/getStockInfo', 'http://webservice.webxml.com.cn/WebServices/StockInfoWS.asmx', 'http://webxml.com.cn/getStockInfo', 'document', TargetNamespace, 'SOAP', 'literal'
      , WSDLLocation]);
  try
    Result := nil;
    lMessage.InitializeRequestMessage(lTransportChannel, 'NewLibrary', __InterfaceName, 'getStockInfo');
    lMessage.Write('getStockInfo', System.TypeInfo(NewLibrary_Intf.getStockInfo), getStockInfo, []);
    lMessage.Finalize;

    lTransportChannel.Dispatch(lMessage);

    lMessage.Read('getStockInfoResponse', System.TypeInfo(NewLibrary_Intf.getStockInfoResponse), Result, []);
  finally
    lMessage.UnsetAttributes(lTransportChannel);
    lMessage.FreeStream;
    lMessage := nil;
    lTransportChannel := nil;
  end;
end;

initialization
  RegisterROClass(getStockInfo);
  RegisterROClass(getStockInfoResponse);
  RegisterROClass(ArrayOfString);
  RegisterProxyClass(IStockInfoWSSoap_IID, TStockInfoWSSoap_Proxy);
  RegisterProxyClass(IStockInfoWSSoap12_IID, TStockInfoWSSoap12_Proxy);


finalization
  UnregisterROClass(getStockInfo);
  UnregisterROClass(getStockInfoResponse);
  UnregisterROClass(ArrayOfString);
  UnregisterProxyClass(IStockInfoWSSoap_IID);
  UnregisterProxyClass(IStockInfoWSSoap12_IID);


end.
