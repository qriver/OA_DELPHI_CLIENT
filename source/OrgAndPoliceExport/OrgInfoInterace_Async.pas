unit OrgInfoInterace_Async;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ Do not modify this unit manually, or your changes will be lost when this   }
{ unit is regenerated the next time you compile the project.                 }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, TypInfo,
  {RemObjects:} uROXMLIntf, uROClasses, uROTypes, uROClientIntf, uROAsync,
  {Project:} OrgInfoInterace_Intf;

type
  TSeekOrigin = Classes.TSeekOrigin; // fake declaration
  { IOrgInfoService_Async }
  IOrgInfoService_Async = interface(IROAsyncInterface)
    ['{77272C3B-D87A-47AF-B078-EC6F225BE508}']
    procedure Invoke_FNGETDEPINFO;
    procedure Invoke_FNGETUSERINFO;
    procedure Invoke_FNGETUSERINFOBYCODE(const ZZINFO: ZZINFO);
    function Retrieve_FNGETDEPINFO: OAINFO;
    function Retrieve_FNGETUSERINFO: OAINFO;
    function Retrieve_FNGETUSERINFOBYCODE: OAINFO;
  end;

  { CoOrgInfoService_Async }
  CoOrgInfoService_Async = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IOrgInfoService_Async;
  end;

  { TOrgInfoService_AsyncProxy }
  TOrgInfoService_AsyncProxy = class(TROAsyncProxy, IOrgInfoService_Async)
  private
  protected
    function __GetInterfaceName:string; override;

    procedure Invoke_FNGETDEPINFO;
    procedure Invoke_FNGETUSERINFO;
    procedure Invoke_FNGETUSERINFOBYCODE(const uZZINFO: ZZINFO);
    function Retrieve_FNGETDEPINFO: OAINFO;
    function Retrieve_FNGETUSERINFO: OAINFO;
    function Retrieve_FNGETUSERINFOBYCODE: OAINFO;
  end;

implementation

uses
  {vcl:} SysUtils, uROClient;

{ CoOrgInfoService }

class function CoOrgInfoService_Async.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IOrgInfoService_Async;
begin
  result := TOrgInfoService_AsyncProxy.Create(aMessage, aTransportChannel);
end;

{ TOrgInfoService_AsyncProxy }

function TOrgInfoService_AsyncProxy.__GetInterfaceName:string;
begin
  result := 'OrgInfoService';
end;

procedure TOrgInfoService_AsyncProxy.Invoke_FNGETDEPINFO;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FNGETDEPINFO');

    lMessage.SetAttributes(lTransportChannel, ['Action', 'InputNamespace', 'Location', 'OutputNamespace', 'remap_FNGETDEPINFO', 'remap_FNGETUSERINFO', 'remap_FNGETUSERINFOBYCODE'
      , 'TargetNamespace', 'Type', 'Use', 'Wsdl'], 
      ['FNGETDEPINFO', 'urn:DefaultNamespace', 'http://oa.domino.yc.hb:80/indishare/indiwscenter.nsf/wsDep?OpenWebService', 'urn:DefaultNamespace', 'FNGETDEPINFO', 'FNGETUSERINFO', 'FNGETUSERINFOBYCODE'
      , TargetNamespace, 'SOAP', 'literal', WSDLLocation]);
    lMessage.InitializeRequestMessage(lTransportChannel, 'OrgInfoInterace', __InterfaceName, 'FNGETDEPINFO');
    __DispatchAsyncRequest('FNGETDEPINFO',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TOrgInfoService_AsyncProxy.Retrieve_FNGETDEPINFO: OAINFO;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('FNGETDEPINFO');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('FNGETDEPINFOReturn', TypeInfo(OAINFO), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TOrgInfoService_AsyncProxy.Invoke_FNGETUSERINFO;
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FNGETUSERINFO');

    lMessage.SetAttributes(lTransportChannel, ['Action', 'InputNamespace', 'Location', 'OutputNamespace', 'remap_FNGETDEPINFO', 'remap_FNGETUSERINFO', 'remap_FNGETUSERINFOBYCODE'
      , 'TargetNamespace', 'Type', 'Use', 'Wsdl'], 
      ['FNGETUSERINFO', 'urn:DefaultNamespace', 'http://oa.domino.yc.hb:80/indishare/indiwscenter.nsf/wsDep?OpenWebService', 'urn:DefaultNamespace', 'FNGETDEPINFO', 'FNGETUSERINFO', 'FNGETUSERINFOBYCODE'
      , TargetNamespace, 'SOAP', 'literal', WSDLLocation]);
    lMessage.InitializeRequestMessage(lTransportChannel, 'OrgInfoInterace', __InterfaceName, 'FNGETUSERINFO');
    __DispatchAsyncRequest('FNGETUSERINFO',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TOrgInfoService_AsyncProxy.Retrieve_FNGETUSERINFO: OAINFO;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('FNGETUSERINFO');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('FNGETUSERINFOReturn', TypeInfo(OAINFO), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

procedure TOrgInfoService_AsyncProxy.Invoke_FNGETUSERINFOBYCODE(const uZZINFO: ZZINFO);
var
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    __AssertProxyNotBusy('FNGETUSERINFOBYCODE');

    lMessage.SetAttributes(lTransportChannel, ['Action', 'InputNamespace', 'Location', 'OutputNamespace', 'remap_FNGETDEPINFO', 'remap_FNGETUSERINFO', 'remap_FNGETUSERINFOBYCODE'
      , 'TargetNamespace', 'Type', 'Use', 'Wsdl'],
      ['FNGETUSERINFOBYCODE', 'urn:DefaultNamespace', 'http://oa.domino.yc.hb:80/indishare/indiwscenter.nsf/wsDep?OpenWebService', 'urn:DefaultNamespace', 'FNGETDEPINFO', 'FNGETUSERINFO', 'FNGETUSERINFOBYCODE'
      , TargetNamespace, 'SOAP', 'literal', WSDLLocation]);
    lMessage.InitializeRequestMessage(lTransportChannel, 'OrgInfoInterace', __InterfaceName, 'FNGETUSERINFOBYCODE');
    lMessage.Write('ZZINFO', TypeInfo(ZZINFO), uZZINFO, []);
    __DispatchAsyncRequest('FNGETUSERINFOBYCODE',lMessage);
    lMessage.UnsetAttributes(lTransportChannel);
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;

function TOrgInfoService_AsyncProxy.Retrieve_FNGETUSERINFOBYCODE: OAINFO;
var
  __response:TStream;
  tc:TROTransportChannel;
  lRetry:Boolean;
  lMessage: IROMessage;
  lTransportChannel: IROTransportChannel;
begin
  lMessage := __GetMessage;
  lTransportChannel := __TransportChannel;
  try
    result := nil;
    __response := __RetrieveAsyncResponse('FNGETUSERINFOBYCODE');
    try
      try
        lMessage.ReadFromStream(__response);

        lMessage.Read('FNGETUSERINFOBYCODEReturn', TypeInfo(OAINFO), Result, []);

      except
        on E: EROSessionNotFound do begin
          tc := TROTransportChannel(lTransportChannel.GetTransportObject);
          lRetry := False;
          if assigned(tc.OnLoginNeeded) then tc.OnLoginNeeded(tc, e, lRetry);
          if not lRetry then raise;
        end;
        on E: Exception do raise;
      end;
    finally
      __response.Free();
    end;
  finally
    lTransportChannel := nil;
    lMessage := nil;
  end;
end;


initialization
end.
